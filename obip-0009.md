<pre>
OBIP: 9
Title: Data sharing via Pubsub
Author: Chris Pacia <chris@ob1.io>
Discussions-To: Github Issues
Status: Draft
Type: Standards Track
Created: 02/28/2018
Copyright: MIT
</pre>

## Abstract
This obip defines a new data sharing protocol using IPFS pubsub to ensure persistent of content when users are offline.

## Motivation
In basic IPFS content only persists when users go offline if other users have viewed/downloaded the content and those users remain online. Thus IPFS provides no hard garanutees that OpenBazaar stores will remain available when a user goes offline. Currently the protocol tries to remedy this problem by defining a list of "data peers" in the config file and
by pushing content to them on each publish to ensure persistence. The downside to this approach is the sharing of data is limited only to those peers found in the config file. While users remain free to change the default list of data peers, in practice very few do which elevates the default peers to the status of critcal infrastructure. 

By creating a pubsub channel for user content anyone on the network is free to subscribe to the channel and receive updates to all new content published on the network. They are then free to sort through that content and decide what they want to re-seed.

## Specification

#### Protocol IDs
| Network       | ID            | 
| ------------- |:-------------:|
| Mainnet       | /openbazaar/floodsub/1.0.0 | 
| Testnet       |  /openbazaar/floodsub/testnet/1.0.0      |

#### Channel ID

The pubsub channel ID is `zdj7Wdn68j9nHZZgksKfPQJG8XDZhqRpNKPJSgb7hk2wj5oaP` which is the CIDv1 (type DagProtobuf) of the sha256 multihash of []byte("floodsub:usercontent").

### Message Format
```protobuf
syntax = "proto2";

message RPC {
	repeated SubOpts subscriptions = 1;
	repeated Message publish = 2;

	message SubOpts {
		optional bool subscribe = 1; // subscribe or unsubcribe
		optional string topicid = 2;
	}
}

message Message {
	optional bytes from = 1;
	optional bytes data = 2;
	optional bytes seqno = 3;
	repeated string topicIDs = 4;
}

// topicID = hash(topicDescriptor); (not the topic.name)
message TopicDescriptor {
	optional string name = 1;
	optional AuthOpts auth = 2;
	optional EncOpts enc = 3;

	message AuthOpts {
		optional AuthMode mode = 1;
		repeated bytes keys = 2; // root keys to trust

		enum AuthMode {
			NONE = 0; // no authentication, anyone can publish
			KEY = 1; // only messages signed by keys in the topic descriptor are accepted
			WOT = 2; // web of trust, certificates can allow publisher set to grow
		}
	}

	message EncOpts {
		optional EncMode mode = 1;
		repeated bytes keyHashes = 2; // the hashes of the shared keys used (salted)

		enum EncMode {
			NONE = 0; // no encryption, anyone can read
			SHAREDKEY = 1; // messages are encrypted with shared key
			WOT = 2; // web of trust, certificates can allow publisher set to grow
		}
	}
}
```

#### Subscribe

To `subscribe` to the content sharing channel a node MUST:

1) Make a `GET_PROVIDERS` query in the DHT using the channel ID as the key.
2) Pick at least eight of the returned providers and open a connection to them.
3) Send a `hello` packet to each peer upon connection.
4) Set self as a provider for the channel ID in the DHT using the `ADD_PROVIDERS` command.

The `hello` packet contains only the list of topic subscriptions. Currently the only topic for this channel is `rawblocks`. 

#### Publish

1) Prior to updating its root directory the node should fetch a list of CIDs in its graph.
2) After updating the root directory the node should calculate the diff between old graph and new graph.
3) Make a `GET_PROVIDERS` query in the DHT using the channel ID as the key.
4) Pick at least eight of the returned providers and open a connection to them.
5) For each CID in the diff publish a `Message` to each peer using the corresponding raw block data as `Message.data` with a topic of `rawblocks`. 
